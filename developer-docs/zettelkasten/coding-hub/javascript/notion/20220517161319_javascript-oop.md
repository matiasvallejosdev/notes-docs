# Object Oriented Programming

Tags: #oop #javascript

**Inspired by**
- [Javascript Definition](20220517161029_javascript-definition.md)

**Links**   
- [Is JavaScript Object oriented?](https://linuxhint.com/is-javascript-object-oriented/)
- [MDN Docs](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming#oop_and_javascript)
- [Intro to OOP](https://medium.com/swlh/intro-to-object-oriented-programming-in-javascript-fe90c70ab316)
- [OOP Code](../first-splash/oop.js)

## Content

The core idea in object-oriented programming is to divide programs into smaller pieces and make each piece responsible for managing its own state.

When we talk about [OOP](../../notion/20220517163213_poo.md) in JavaScript there is no class.Actually it is a prototype based programming. In this programming style, the object encapsulates the properties, i.e., its methods and data, instead of a class. You can add new properties to this object at any time.

The core concept in oop is:

- [Encapsulation](#encapsulation)
- [Inheritance](#inheritance)
- [Polymorphism](#polymorphism)

### Arrow functions vs Functions

[Arrow functions vs functions](../../../bibliography/notes/20220518155951_la-diferencia-entre-functions-y-arrow-function.md)

Since each function has its own this binding, whose value depends on the way it is called, you cannot refer to the this of the wrapping scope in a regular function defined with the function keyword.

Arrow functions are different—they do not bind their own this but can see the this binding of the scope around them.

### Prototypes

In every single object you have a great ancestral prototype, the entity behind almost all objects, Object.prototype. The prototype relations of JavaScript objects form a tree-shaped structure, and at the root of this structure sits Object.prototype. It provides a few methods that show up in all objects, such as toString, which converts an object to a string representation.

### Classes 

A class defines the shape of a type of object—what methods and properties it has. Such an object is called an instance of the class. Prototypes are useful for defining properties for which all instances of a class share the same value, such as methods. 

Constructors (all functions, in fact) automatically get a property named prototype, which by default holds a plain, empty object that derives from Object.prototype. You can overwrite it with a new object if you want. Or you can add properties to the existing object, as the example does.

### OOP in JavaScript

JavaScript is not a class-based object-oriented language. But it still has ways of using object oriented programming ([OOP](https://www.freecodecamp.org/news/how-javascript-implements-oop/)).

JavaScript is not an object-oriented language, it was not designed to be one, the notion of classes is absolutely not applicable to it. While everything in JS is indeed an object, these objects are different from the ones in Java or C#. In JS, an object is simply a Map data structure with a somewhat sophisticated lookup procedure. That is it, really. And when I say everything is an object, I mean it: even functions are objects. 

The most popular model of OOP is class-based. But as I mentioned, JavaScript isn't a classed-based langauge – it's is a prototype-based langauge.

> A prototype-based language has the notion of a prototypical object, an object used as a template from which to get the initial properties for a new object.

First, in class-based OOP, classes and objects are two separate constructs, and objects are always created as instances of classes. Also, there is a distinction between the feature used to define a class (the class syntax itself) and the feature used to instantiate an object (a constructor). In JavaScript, we can and often do create objects without any separate class definition, either using a function or an object literal. This can make working with objects much more lightweight than it is in classical OOP.

Second, although a prototype chain looks like an inheritance hierarchy and behaves like it in some ways, it's different in others. When a subclass is instantiated, a single object is created which combines properties defined in the subclass with properties defined further up the hierarchy. With prototyping, each level of the hierarchy is represented by a separate object, and they are linked together via the `__proto__` property. The prototype chain's behavior is less like inheritance and more like delegation. Delegation is a programming pattern where an object, when asked to perform a task, can perform the task itself or ask another object (its delegate) to perform the task on its behalf. In many ways, delegation is a more flexible way of combining objects than inheritance 

### Prototype-based and Class-based OOP have their advantages

In prototype based programming, there is no need to declare class as pre-planning about the sort of properties required before creating an object.Since no class needs to be made, you can create the object directly. This also offers flexibility; hence, any changes to the objects can easily and quickly be made while they’re being used.

While all these advantages exist in Prototype-based programming, there is a higher risk of incorrectness as abrupt changes can easily be made. Whereas in the Class-based approach, the blueprints layout a plan beforehand, decreasing the chances of bugs arising.

### ES6 Class keyword

With the release of ES6 in 2015, the long-awaited class keyword arrived in JavaScript. It was done as per numerous requests by the community because people were feeling uncomfortable coming from object-oriented languages. But they missed one important point.

> JavaScript is not an object-oriented language. It is a prototype-based language.

All of these issues can be mitigated with JS objects and prototype delegation. JS offers so much more that classes can ever do, yet most developers are blind to it. If you want to truly master JS, you need to embrace its philosophy and move away from dogmatic class-based thinking.

The class keyword starts a class declaration, which allows us to define a constructor and a set of methods all in a single place. Any number of methods may be written inside the declaration’s braces. The one named constructor is treated specially.

Class declarations currently allow only methods—properties that hold functions—to be added to the prototype. This can be somewhat inconvenient when you want to save a non-function value in there.

### Class as Template

We use classes in OOP as templates for creating objects. An object is an “instance of a class” and “instantiation” is the creation of an object based on a class. The code is defined in the class but can’t execute unless it is in a live object.

```javascript
// You could define as a function
function Product(_name, _price) 
{   
    const name = _name;  
    const price = _price;
    this.getName = function() {    return name;  };
    this.getPrice = function() {    return price;  };
}

// You could define the same with class name
class Product
{
    constructor(name, price){
        this._name;
        this._price;
    }

    getName() {return this._name};
    getPrice() {return this._price};
}
```

### Encapsulation

Such program pieces are modeled using objects. Their interface consists of a specific set of methods and properties. Properties that are part of the interface are called public. The others, which outside code should not be touching, are called private.

In javascript programming language we don't have that aproach to define if a property is public or private instead javascript programmers sometimes uses an underscore to define it. Separating interface from implementation is a great idea. It is usually called encapsulation.

### Polymorphism

This is a simple instance of a powerful idea. When a piece of code is written to work with objects that have a certain interface—in this case, a toString method—any kind of object that happens to support this interface can be plugged into the code, and it will just work.

This technique is called polymorphism. Polymorphic code can work with values of different shapes, as long as they support the interface it expects.

### Inheritance

JavaScript’s prototype system makes it possible to create a new class, much like the old class, but with new definitions for some of its properties. The prototype for the new class derives from the old prototype but adds a new definition for, say, the set method.

In object-oriented programming terms, this is called inheritance. The new class inherits properties and behavior from the old class.

```javascript
class Rectangle extends Area{
    // Your new class inherits properties from the old
    constructor(value){
        super(value)
    }
}
```
The use of the word extends indicates that this class shouldn’t be directly based on the default Object prototype but on some other class. This is called the superclass. The derived class is the subclass.

Inheritance allows us to build slightly different data types from existing data types with relatively little work. It is a fundamental part of the object-oriented tradition, alongside encapsulation and polymorphism. But while the latter two are now generally regarded as wonderful ideas, inheritance is more controversial.

Whereas encapsulation and polymorphism can be used to separate pieces of code from each other, reducing the tangledness of the overall program, inheritance fundamentally ties classes together, creating more tangle. When inheriting from a class, you usually have to know more about how it works than when simply using it. Inheritance can be a useful tool, and I use it now and then in my own programs, but it shouldn’t be the first tool you reach for, and you probably shouldn’t actively go looking for opportunities to construct class hierarchies (family trees of classes).
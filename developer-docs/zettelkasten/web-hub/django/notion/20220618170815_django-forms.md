# Django Forms

**Tags:** #django-forms #forms-models #django-crud

**Inspired by**
- [Django templates](20220609101616_django-templates.md)

**Links**
- [Django Forms Docs](https://docs.djangoproject.com/en/4.0/topics/forms/)

## Content

Forms are a way to create a form in your website. You can use them to create new data in your database. To use them you need to add new class form with meta data and you need to import it into your templates.

In the context of a web application, ‘form’ might refer to that HTML `<form>`, or  to the Django Form that produces it, or to the structured data returned when it is submitted, or to the end-to-end working collection of these parts.

This defines a Form class with a single field (your_name). We’ve applied a human-friendly label to the field, which will appear in the `<label>` when it’s rendered (although in this case, the label we specified is actually the same one that would be generated automatically if we had omitted it).

### Form roles

Django’s form functionality can simplify and automate vast portions of this work, and can also do it more securely than most programmers would be able to do in code they wrote themselves.

Django handles three distinct parts of the work involved in forms:

- preparing and restructuring data to make it ready for rendering
- creating HTML forms for the data
- receiving and processing submitted forms and data from the client

It is possible to write code that does all of this manually, but Django can take care of it all for you.

### Form class

At the heart of this system of components is Django’s Form class. In much the same way that a Django model describes the logical structure of an object, its behavior, and the way its parts are represented to us, a Form class describes a form and determines how it works and appears.

```django html
class ArticleForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = ['title', 'content']
```

In fact if your form is going to be used to directly add or edit a Django model, a ModelForm can save you a great deal of time, effort, and code, because it will build a form, along with the appropriate fields and their attributes, from a Model class.

### Raw HTML form

With forms you could create your own POST and GET actions to send data to the server. But you can also use the HTML form tag to create a form.

```django html 
<form action="/" method="POST">
    {{csrf_token}}
    <input type="text" name="your_name" />
    <input type="submit" value="Submit" />
</form>
```

### Django Pure Forms

Django pure forms are the way to create your own and custom forms withou using a model. You can use them to create your own forms.

In first place you need to create your django form in order to validate your request and handle it.

```django html

class PersonForm(forms.Form):
    person_name = forms.CharField(label='Your name', max_length=100, required=True) 

```

In second place you need to import that form into your html file to create client form.

```django html 
{{extends 'base.html'}}

<!-- .forms -->
<form action="/" method="POST">
    {{csrf_token}}
    <input type="text" name="your_name" />
    <input type="submit" value="Submit" />
</form>
```

In thir place you need to import that models and create new objects using that validated data and handling it with url request and the method `POST`.

```django html
from .models import Person

<!-- .views -->
def person_create_view(request):
    form = PersonForm(request.POST or None)
    if form.is_valid():
        form.save()
        form = PersonForm()
        Person.objects.create(**form.cleaned_data)
    context = {'form': form}
    return render(request, 'people/create.html', context)
```

### Form widgets

A widget is Django’s representation of an HTML input element. The widget handles the rendering of the HTML, and the extraction of data from a GET/POST dictionary that corresponds to the widget.

The HTML generated by the built-in widgets uses HTML5 syntax, targeting <!DOCTYPE html>. For example, it uses boolean attributes such as checked rather than the XHTML style of checked='checked'.

With that you could perform your forms in order to generate your custom html output. You can use the following widgets:

- TextInput: A text input widget.
- Textarea: A textarea widget.
- DateInput: A date input widget.
- DecimalInput: A decimal input widget.
- IntegerInput: An integer input widget.
- EmailInput: An email input widget.
- URLInput: A URL input widget.
- PasswordInput: A password input widget.
- Select: A select widget.
- SelectMultiple: A select multiple widget.
- CheckboxInput: A checkbox input widget.
- CheckboxSelectMultiple: A checkbox select multiple widget.
- RadioSelect: A radio select widget.
- FileInput: A file input widget.
- ClearableFileInput: A clearable file input widget.


### Custom methods

You could validate using your own methods. That allow you to validate your data using business rules.

```django html
class PersonForm(forms.Form):
    person_name = forms.CharField(label='Your name', max_length=100, required=True) 
    def clean_person_name(self):
        person_name = self.cleaned_data.get('person_name')
        if person_name == 'admin':
            raise ValidationError('You cannot use the word "admin"')
        return person_name
```
